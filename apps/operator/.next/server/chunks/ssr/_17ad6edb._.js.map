{"version":3,"sources":["../../../../node_modules/.pnpm/next%4016.0.10_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/dynamic-rendering-utils.ts","../../../../node_modules/.pnpm/next%4016.0.10_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/shared/lib/lazy-dynamic/bailout-to-csr.ts","../../../../node_modules/.pnpm/next%4016.0.10_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/client/components/hooks-server-context.ts","../../../../node_modules/.pnpm/next%4016.0.10_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/client/components/static-generation-bailout.ts","../../../../node_modules/.pnpm/next%4016.0.10_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/lib/framework/boundary-constants.tsx","../../../../node_modules/.pnpm/next%4016.0.10_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/lib/scheduler.ts","../../../../node_modules/.pnpm/next%4016.0.10_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/shared/lib/invariant-error.ts","../../../../node_modules/.pnpm/next%4016.0.10_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/shared/lib/promise-with-resolvers.ts","../../../../node_modules/.pnpm/next%4016.0.10_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/app-render/staged-rendering.ts","../../../../node_modules/.pnpm/next%4016.0.10_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/app-render/dynamic-rendering.ts","../../../../node_modules/.pnpm/next%4016.0.10_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/web/spec-extension/cookies.ts","../../../../node_modules/.pnpm/next%4016.0.10_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/web/spec-extension/adapters/reflect.ts","../../../../node_modules/.pnpm/next%4016.0.10_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/web/spec-extension/adapters/request-cookies.ts","../../../../node_modules/.pnpm/next%4016.0.10_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/create-deduped-by-callsite-server-error-logger.ts","../../../../node_modules/.pnpm/next%4016.0.10_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/request/utils.ts","../../../../node_modules/.pnpm/next%4016.0.10_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/request/cookies.ts","../../../../node_modules/.pnpm/next%4016.0.10_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/web/spec-extension/adapters/headers.ts","../../../../node_modules/.pnpm/next%4016.0.10_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/request/headers.ts","../../../../node_modules/.pnpm/next%4016.0.10_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/request/draft-mode.ts","../../../../node_modules/.pnpm/next%4016.0.10_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/headers.js","../../../../lib/operator-session.ts"],"sourcesContent":["import type { NonStaticRenderStage } from './app-render/staged-rendering'\nimport type { RequestStore } from './app-render/work-unit-async-storage.external'\n\nexport function isHangingPromiseRejectionError(\n  err: unknown\n): err is HangingPromiseRejectionError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === HANGING_PROMISE_REJECTION\n}\n\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION'\n\nclass HangingPromiseRejectionError extends Error {\n  public readonly digest = HANGING_PROMISE_REJECTION\n\n  constructor(\n    public readonly route: string,\n    public readonly expression: string\n  ) {\n    super(\n      `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context. This occurred at route \"${route}\".`\n    )\n  }\n}\n\ntype AbortListeners = Array<(err: unknown) => void>\nconst abortListenersBySignal = new WeakMap<AbortSignal, AbortListeners>()\n\n/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for cacheComponents where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */\nexport function makeHangingPromise<T>(\n  signal: AbortSignal,\n  route: string,\n  expression: string\n): Promise<T> {\n  if (signal.aborted) {\n    return Promise.reject(new HangingPromiseRejectionError(route, expression))\n  } else {\n    const hangingPromise = new Promise<T>((_, reject) => {\n      const boundRejection = reject.bind(\n        null,\n        new HangingPromiseRejectionError(route, expression)\n      )\n      let currentListeners = abortListenersBySignal.get(signal)\n      if (currentListeners) {\n        currentListeners.push(boundRejection)\n      } else {\n        const listeners = [boundRejection]\n        abortListenersBySignal.set(signal, listeners)\n        signal.addEventListener(\n          'abort',\n          () => {\n            for (let i = 0; i < listeners.length; i++) {\n              listeners[i]()\n            }\n          },\n          { once: true }\n        )\n      }\n    })\n    // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n    // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n    // your own promise out of it you'll need to ensure you handle the error when it rejects.\n    hangingPromise.catch(ignoreReject)\n    return hangingPromise\n  }\n}\n\nfunction ignoreReject() {}\n\nexport function makeDevtoolsIOAwarePromise<T>(\n  underlying: T,\n  requestStore: RequestStore,\n  stage: NonStaticRenderStage\n): Promise<T> {\n  if (requestStore.stagedRendering) {\n    // We resolve each stage in a timeout, so React DevTools will pick this up as IO.\n    return requestStore.stagedRendering.delayUntilStage(\n      stage,\n      undefined,\n      underlying\n    )\n  }\n  // in React DevTools if we resolve in a setTimeout we will observe\n  // the promise resolution as something that can suspend a boundary or root.\n  return new Promise<T>((resolve) => {\n    // Must use setTimeout to be considered IO React DevTools. setImmediate will not work.\n    setTimeout(() => {\n      resolve(underlying)\n    }, 0)\n  })\n}\n","// This has to be a shared module which is shared between client component error boundary and dynamic component\nconst BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING'\n\n/** An error that should be thrown when we want to bail out to client-side rendering. */\nexport class BailoutToCSRError extends Error {\n  public readonly digest = BAILOUT_TO_CSR\n\n  constructor(public readonly reason: string) {\n    super(`Bail out to client-side rendering: ${reason}`)\n  }\n}\n\n/** Checks if a passed argument is an error that is thrown if we want to bail out to client-side rendering. */\nexport function isBailoutToCSRError(err: unknown): err is BailoutToCSRError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === BAILOUT_TO_CSR\n}\n","const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE'\n\nexport class DynamicServerError extends Error {\n  digest: typeof DYNAMIC_ERROR_CODE = DYNAMIC_ERROR_CODE\n\n  constructor(public readonly description: string) {\n    super(`Dynamic server usage: ${description}`)\n  }\n}\n\nexport function isDynamicServerError(err: unknown): err is DynamicServerError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === DYNAMIC_ERROR_CODE\n}\n","const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT'\n\nexport class StaticGenBailoutError extends Error {\n  public readonly code = NEXT_STATIC_GEN_BAILOUT\n}\n\nexport function isStaticGenBailoutError(\n  error: unknown\n): error is StaticGenBailoutError {\n  if (typeof error !== 'object' || error === null || !('code' in error)) {\n    return false\n  }\n\n  return error.code === NEXT_STATIC_GEN_BAILOUT\n}\n","export const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__'\nexport const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__'\nexport const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__'\nexport const ROOT_LAYOUT_BOUNDARY_NAME = '__next_root_layout_boundary__'\n","export type ScheduledFn<T = void> = () => T | PromiseLike<T>\nexport type SchedulerFn<T = void> = (cb: ScheduledFn<T>) => void\n\n/**\n * Schedules a function to be called on the next tick after the other promises\n * have been resolved.\n *\n * @param cb the function to schedule\n */\nexport const scheduleOnNextTick = (cb: ScheduledFn<void>) => {\n  // We use Promise.resolve().then() here so that the operation is scheduled at\n  // the end of the promise job queue, we then add it to the next process tick\n  // to ensure it's evaluated afterwards.\n  //\n  // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255\n  //\n  Promise.resolve().then(() => {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      setTimeout(cb, 0)\n    } else {\n      process.nextTick(cb)\n    }\n  })\n}\n\n/**\n * Schedules a function to be called using `setImmediate` or `setTimeout` if\n * `setImmediate` is not available (like in the Edge runtime).\n *\n * @param cb the function to schedule\n */\nexport const scheduleImmediate = (cb: ScheduledFn<void>): void => {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    setTimeout(cb, 0)\n  } else {\n    setImmediate(cb)\n  }\n}\n\n/**\n * returns a promise than resolves in a future task. There is no guarantee that the task it resolves in\n * will be the next task but if you await it you can at least be sure that the current task is over and\n * most usefully that the entire microtask queue of the current task has been emptied.\n */\nexport function atLeastOneTask() {\n  return new Promise<void>((resolve) => scheduleImmediate(resolve))\n}\n\n/**\n * This utility function is extracted to make it easier to find places where we are doing\n * specific timing tricks to try to schedule work after React has rendered. This is especially\n * important at the moment because Next.js uses the edge builds of React which use setTimeout to\n * schedule work when you might expect that something like setImmediate would do the trick.\n *\n * Long term we should switch to the node versions of React rendering when possible and then\n * update this to use setImmediate rather than setTimeout\n */\nexport function waitAtLeastOneReactRenderTask(): Promise<void> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return new Promise((r) => setTimeout(r, 0))\n  } else {\n    return new Promise((r) => setImmediate(r))\n  }\n}\n","export class InvariantError extends Error {\n  constructor(message: string, options?: ErrorOptions) {\n    super(\n      `Invariant: ${message.endsWith('.') ? message : message + '.'} This is a bug in Next.js.`,\n      options\n    )\n    this.name = 'InvariantError'\n  }\n}\n","export function createPromiseWithResolvers<T>(): PromiseWithResolvers<T> {\n  // Shim of Stage 4 Promise.withResolvers proposal\n  let resolve: (value: T | PromiseLike<T>) => void\n  let reject: (reason: any) => void\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n  return { resolve: resolve!, reject: reject!, promise }\n}\n","import { InvariantError } from '../../shared/lib/invariant-error'\nimport { createPromiseWithResolvers } from '../../shared/lib/promise-with-resolvers'\n\nexport enum RenderStage {\n  Static = 1,\n  Runtime = 2,\n  Dynamic = 3,\n}\n\nexport type NonStaticRenderStage = RenderStage.Runtime | RenderStage.Dynamic\n\nexport class StagedRenderingController {\n  currentStage: RenderStage = RenderStage.Static\n\n  private runtimeStagePromise = createPromiseWithResolvers<void>()\n  private dynamicStagePromise = createPromiseWithResolvers<void>()\n\n  constructor(private abortSignal: AbortSignal | null = null) {\n    if (abortSignal) {\n      abortSignal.addEventListener(\n        'abort',\n        () => {\n          const { reason } = abortSignal\n          if (this.currentStage < RenderStage.Runtime) {\n            this.runtimeStagePromise.promise.catch(ignoreReject) // avoid unhandled rejections\n            this.runtimeStagePromise.reject(reason)\n          }\n          if (this.currentStage < RenderStage.Dynamic) {\n            this.dynamicStagePromise.promise.catch(ignoreReject) // avoid unhandled rejections\n            this.dynamicStagePromise.reject(reason)\n          }\n        },\n        { once: true }\n      )\n    }\n  }\n\n  advanceStage(stage: NonStaticRenderStage) {\n    // If we're already at the target stage or beyond, do nothing.\n    // (this can happen e.g. if sync IO advanced us to the dynamic stage)\n    if (this.currentStage >= stage) {\n      return\n    }\n    this.currentStage = stage\n    // Note that we might be going directly from Static to Dynamic,\n    // so we need to resolve the runtime stage as well.\n    if (stage >= RenderStage.Runtime) {\n      this.runtimeStagePromise.resolve()\n    }\n    if (stage >= RenderStage.Dynamic) {\n      this.dynamicStagePromise.resolve()\n    }\n  }\n\n  private getStagePromise(stage: NonStaticRenderStage): Promise<void> {\n    switch (stage) {\n      case RenderStage.Runtime: {\n        return this.runtimeStagePromise.promise\n      }\n      case RenderStage.Dynamic: {\n        return this.dynamicStagePromise.promise\n      }\n      default: {\n        stage satisfies never\n        throw new InvariantError(`Invalid render stage: ${stage}`)\n      }\n    }\n  }\n\n  waitForStage(stage: NonStaticRenderStage) {\n    return this.getStagePromise(stage)\n  }\n\n  delayUntilStage<T>(\n    stage: NonStaticRenderStage,\n    displayName: string | undefined,\n    resolvedValue: T\n  ) {\n    const ioTriggerPromise = this.getStagePromise(stage)\n\n    const promise = makeDevtoolsIOPromiseFromIOTrigger(\n      ioTriggerPromise,\n      displayName,\n      resolvedValue\n    )\n\n    // Analogously to `makeHangingPromise`, we might reject this promise if the signal is invoked.\n    // (e.g. in the case where we don't want want the render to proceed to the dynamic stage and abort it).\n    // We shouldn't consider this an unhandled rejection, so we attach a noop catch handler here to suppress this warning.\n    if (this.abortSignal) {\n      promise.catch(ignoreReject)\n    }\n    return promise\n  }\n}\n\nfunction ignoreReject() {}\n\n// TODO(restart-on-cache-miss): the layering of `delayUntilStage`,\n// `makeDevtoolsIOPromiseFromIOTrigger` and and `makeDevtoolsIOAwarePromise`\n// is confusing, we should clean it up.\nfunction makeDevtoolsIOPromiseFromIOTrigger<T>(\n  ioTrigger: Promise<any>,\n  displayName: string | undefined,\n  resolvedValue: T\n): Promise<T> {\n  // If we create a `new Promise` and give it a displayName\n  // (with no userspace code above us in the stack)\n  // React Devtools will use it as the IO cause when determining \"suspended by\".\n  // In particular, it should shadow any inner IO that resolved/rejected the promise\n  // (in case of staged rendering, this will be the `setTimeout` that triggers the relevant stage)\n  const promise = new Promise<T>((resolve, reject) => {\n    ioTrigger.then(resolve.bind(null, resolvedValue), reject)\n  })\n  if (displayName !== undefined) {\n    // @ts-expect-error\n    promise.displayName = displayName\n  }\n  return promise\n}\n","/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport type {\n  WorkUnitStore,\n  RequestStore,\n  PrerenderStoreLegacy,\n  PrerenderStoreModern,\n  PrerenderStoreModernRuntime,\n} from '../app-render/work-unit-async-storage.external'\n\n// Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react'\n\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport {\n  getRuntimeStagePromise,\n  throwForMissingRequestStore,\n  workUnitAsyncStorage,\n} from './work-unit-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n  ROOT_LAYOUT_BOUNDARY_NAME,\n} from '../../lib/framework/boundary-constants'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { RenderStage } from './staged-rendering'\n\nconst hasPostpone = typeof React.unstable_postpone === 'function'\n\nexport type DynamicAccess = {\n  /**\n   * If debugging, this will contain the stack trace of where the dynamic access\n   * occurred. This is used to provide more information to the user about why\n   * their page is being rendered dynamically.\n   */\n  stack?: string\n\n  /**\n   * The expression that was accessed dynamically.\n   */\n  expression: string\n}\n\n// Stores dynamic reasons used during an RSC render.\nexport type DynamicTrackingState = {\n  /**\n   * When true, stack information will also be tracked during dynamic access.\n   */\n  readonly isDebugDynamicAccesses: boolean | undefined\n\n  /**\n   * The dynamic accesses that occurred during the render.\n   */\n  readonly dynamicAccesses: Array<DynamicAccess>\n\n  syncDynamicErrorWithStack: null | Error\n}\n\n// Stores dynamic reasons used during an SSR render.\nexport type DynamicValidationState = {\n  hasSuspenseAboveBody: boolean\n  hasDynamicMetadata: boolean\n  hasDynamicViewport: boolean\n  hasAllowedDynamic: boolean\n  dynamicErrors: Array<Error>\n}\n\nexport function createDynamicTrackingState(\n  isDebugDynamicAccesses: boolean | undefined\n): DynamicTrackingState {\n  return {\n    isDebugDynamicAccesses,\n    dynamicAccesses: [],\n    syncDynamicErrorWithStack: null,\n  }\n}\n\nexport function createDynamicValidationState(): DynamicValidationState {\n  return {\n    hasSuspenseAboveBody: false,\n    hasDynamicMetadata: false,\n    hasDynamicViewport: false,\n    hasAllowedDynamic: false,\n    dynamicErrors: [],\n  }\n}\n\nexport function getFirstDynamicReason(\n  trackingState: DynamicTrackingState\n): undefined | string {\n  return trackingState.dynamicAccesses[0]?.expression\n}\n\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */\nexport function markCurrentScopeAsDynamic(\n  store: WorkStore,\n  workUnitStore: undefined | Exclude<WorkUnitStore, PrerenderStoreModern>,\n  expression: string\n): void {\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'unstable-cache':\n        // Inside cache scopes, marking a scope as dynamic has no effect,\n        // because the outer cache scope creates a cache boundary. This is\n        // subtly different from reading a dynamic data source, which is\n        // forbidden inside a cache scope.\n        return\n      case 'private-cache':\n        // A private cache scope is already dynamic by definition.\n        return\n      case 'prerender-legacy':\n      case 'prerender-ppr':\n      case 'request':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  // If we're forcing dynamic rendering or we're forcing static rendering, we\n  // don't need to do anything here because the entire page is already dynamic\n  // or it's static and it should not throw or postpone here.\n  if (store.forceDynamic || store.forceStatic) return\n\n  if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  }\n\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender-ppr':\n        return postponeWithTracking(\n          store.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      case 'prerender-legacy':\n        workUnitStore.revalidate = 0\n\n        // We aren't prerendering, but we are generating a static page. We need\n        // to bail out of static generation.\n        const err = new DynamicServerError(\n          `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n        )\n        store.dynamicUsageDescription = expression\n        store.dynamicUsageStack = err.stack\n\n        throw err\n      case 'request':\n        if (process.env.NODE_ENV !== 'production') {\n          workUnitStore.usedDynamic = true\n        }\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n\n/**\n * This function is meant to be used when prerendering without cacheComponents or PPR.\n * When called during a build it will cause Next.js to consider the route as dynamic.\n *\n * @internal\n */\nexport function throwToInterruptStaticGeneration(\n  expression: string,\n  store: WorkStore,\n  prerenderStore: PrerenderStoreLegacy\n): never {\n  // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n  const err = new DynamicServerError(\n    `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n  )\n\n  prerenderStore.revalidate = 0\n\n  store.dynamicUsageDescription = expression\n  store.dynamicUsageStack = err.stack\n\n  throw err\n}\n\n/**\n * This function should be used to track whether something dynamic happened even when\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\n * we still track whether dynamic APIs were accessed for helpful messaging\n *\n * @internal\n */\nexport function trackDynamicDataInDynamicRender(workUnitStore: WorkUnitStore) {\n  switch (workUnitStore.type) {\n    case 'cache':\n    case 'unstable-cache':\n      // Inside cache scopes, marking a scope as dynamic has no effect,\n      // because the outer cache scope creates a cache boundary. This is\n      // subtly different from reading a dynamic data source, which is\n      // forbidden inside a cache scope.\n      return\n    case 'private-cache':\n      // A private cache scope is already dynamic by definition.\n      return\n    case 'prerender':\n    case 'prerender-runtime':\n    case 'prerender-legacy':\n    case 'prerender-ppr':\n    case 'prerender-client':\n      break\n    case 'request':\n      if (process.env.NODE_ENV !== 'production') {\n        workUnitStore.usedDynamic = true\n      }\n      break\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nfunction abortOnSynchronousDynamicDataAccess(\n  route: string,\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n\n  const error = createPrerenderInterruptedError(reason)\n\n  prerenderStore.controller.abort(error)\n\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function abortOnSynchronousPlatformIOAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n  // It is important that we set this tracking value after aborting. Aborts are executed\n  // synchronously except for the case where you abort during render itself. By setting this\n  // value late we can use it to determine if any of the aborted tasks are the task that\n  // called the sync IO expression in the first place.\n  if (dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack === null) {\n      dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n    }\n  }\n}\n\nexport function trackSynchronousPlatformIOAccessInDev(\n  requestStore: RequestStore\n): void {\n  // We don't actually have a controller to abort but we do the semantic equivalent by\n  // advancing the request store out of the prerender stage\n  if (requestStore.stagedRendering) {\n    // TODO: error for sync IO in the runtime stage\n    // (which is not currently covered by the validation render in `spawnDynamicValidationInDev`)\n    requestStore.stagedRendering.advanceStage(RenderStage.Dynamic)\n  }\n}\n\n/**\n * use this function when prerendering with cacheComponents. If we are doing a\n * prospective prerender we don't actually abort because we want to discover\n * all caches for the shell. If this is the actual prerender we do abort.\n *\n * This function accepts a prerenderStore but the caller should ensure we're\n * actually running in cacheComponents mode.\n *\n * @internal\n */\nexport function abortAndThrowOnSynchronousRequestDataAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): never {\n  const prerenderSignal = prerenderStore.controller.signal\n  if (prerenderSignal.aborted === false) {\n    // TODO it would be better to move this aborted check into the callsite so we can avoid making\n    // the error object when it isn't relevant to the aborting of the prerender however\n    // since we need the throw semantics regardless of whether we abort it is easier to land\n    // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer\n    // to ideal implementation\n    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n    // It is important that we set this tracking value after aborting. Aborts are executed\n    // synchronously except for the case where you abort during render itself. By setting this\n    // value late we can use it to determine if any of the aborted tasks are the task that\n    // called the sync IO expression in the first place.\n    const dynamicTracking = prerenderStore.dynamicTracking\n    if (dynamicTracking) {\n      if (dynamicTracking.syncDynamicErrorWithStack === null) {\n        dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n      }\n    }\n  }\n  throw createPrerenderInterruptedError(\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n  )\n}\n\n/**\n * This component will call `React.postpone` that throws the postponed error.\n */\ntype PostponeProps = {\n  reason: string\n  route: string\n}\nexport function Postpone({ reason, route }: PostponeProps): never {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  const dynamicTracking =\n    prerenderStore && prerenderStore.type === 'prerender-ppr'\n      ? prerenderStore.dynamicTracking\n      : null\n  postponeWithTracking(route, reason, dynamicTracking)\n}\n\nexport function postponeWithTracking(\n  route: string,\n  expression: string,\n  dynamicTracking: null | DynamicTrackingState\n): never {\n  assertPostpone()\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n\n  React.unstable_postpone(createPostponeReason(route, expression))\n}\n\nfunction createPostponeReason(route: string, expression: string) {\n  return (\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +\n    `React throws this special object to indicate where. It should not be caught by ` +\n    `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`\n  )\n}\n\nexport function isDynamicPostpone(err: unknown) {\n  if (\n    typeof err === 'object' &&\n    err !== null &&\n    typeof (err as any).message === 'string'\n  ) {\n    return isDynamicPostponeReason((err as any).message)\n  }\n  return false\n}\n\nfunction isDynamicPostponeReason(reason: string) {\n  return (\n    reason.includes(\n      'needs to bail out of prerendering at this point because it used'\n    ) &&\n    reason.includes(\n      'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'\n    )\n  )\n}\n\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n  throw new Error(\n    'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'\n  )\n}\n\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED'\n\nfunction createPrerenderInterruptedError(message: string): Error {\n  const error = new Error(message)\n  ;(error as any).digest = NEXT_PRERENDER_INTERRUPTED\n  return error\n}\n\ntype DigestError = Error & {\n  digest: string\n}\n\nexport function isPrerenderInterruptedError(\n  error: unknown\n): error is DigestError {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    (error as any).digest === NEXT_PRERENDER_INTERRUPTED &&\n    'name' in error &&\n    'message' in error &&\n    error instanceof Error\n  )\n}\n\nexport function accessedDynamicData(\n  dynamicAccesses: Array<DynamicAccess>\n): boolean {\n  return dynamicAccesses.length > 0\n}\n\nexport function consumeDynamicAccess(\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n): DynamicTrackingState['dynamicAccesses'] {\n  // We mutate because we only call this once we are no longer writing\n  // to the dynamicTrackingState and it's more efficient than creating a new\n  // array.\n  serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses)\n  return serverDynamic.dynamicAccesses\n}\n\nexport function formatDynamicAPIAccesses(\n  dynamicAccesses: Array<DynamicAccess>\n): string[] {\n  return dynamicAccesses\n    .filter(\n      (access): access is Required<DynamicAccess> =>\n        typeof access.stack === 'string' && access.stack.length > 0\n    )\n    .map(({ expression, stack }) => {\n      stack = stack\n        .split('\\n')\n        // Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4)\n        .filter((line) => {\n          // Exclude Next.js internals from the stack trace.\n          if (line.includes('node_modules/next/')) {\n            return false\n          }\n\n          // Exclude anonymous functions from the stack trace.\n          if (line.includes(' (<anonymous>)')) {\n            return false\n          }\n\n          // Exclude Node.js internals from the stack trace.\n          if (line.includes(' (node:')) {\n            return false\n          }\n\n          return true\n        })\n        .join('\\n')\n      return `Dynamic API Usage Debug - ${expression}:\\n${stack}`\n    })\n}\n\nfunction assertPostpone() {\n  if (!hasPostpone) {\n    throw new Error(\n      `Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`\n    )\n  }\n}\n\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */\nexport function createRenderInBrowserAbortSignal(): AbortSignal {\n  const controller = new AbortController()\n  controller.abort(new BailoutToCSRError('Render in Browser'))\n  return controller.signal\n}\n\n/**\n * In a prerender, we may end up with hanging Promises as inputs due them\n * stalling on connection() or because they're loading dynamic data. In that\n * case we need to abort the encoding of arguments since they'll never complete.\n */\nexport function createHangingInputAbortSignal(\n  workUnitStore: WorkUnitStore\n): AbortSignal | undefined {\n  switch (workUnitStore.type) {\n    case 'prerender':\n    case 'prerender-runtime':\n      const controller = new AbortController()\n\n      if (workUnitStore.cacheSignal) {\n        // If we have a cacheSignal it means we're in a prospective render. If\n        // the input we're waiting on is coming from another cache, we do want\n        // to wait for it so that we can resolve this cache entry too.\n        workUnitStore.cacheSignal.inputReady().then(() => {\n          controller.abort()\n        })\n      } else {\n        // Otherwise we're in the final render and we should already have all\n        // our caches filled.\n        // If the prerender uses stages, we have wait until the runtime stage,\n        // at which point all runtime inputs will be resolved.\n        // (otherwise, a runtime prerender might consider `cookies()` hanging\n        //  even though they'd resolve in the next task.)\n        //\n        // We might still be waiting on some microtasks so we\n        // wait one tick before giving up. When we give up, we still want to\n        // render the content of this cache as deeply as we can so that we can\n        // suspend as deeply as possible in the tree or not at all if we don't\n        // end up waiting for the input.\n        const runtimeStagePromise = getRuntimeStagePromise(workUnitStore)\n        if (runtimeStagePromise) {\n          runtimeStagePromise.then(() =>\n            scheduleOnNextTick(() => controller.abort())\n          )\n        } else {\n          scheduleOnNextTick(() => controller.abort())\n        }\n      }\n\n      return controller.signal\n    case 'prerender-client':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      return undefined\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nexport function annotateDynamicAccess(\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n) {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function useDynamicRouteParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workStore && workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender-client':\n      case 'prerender': {\n        const fallbackParams = workUnitStore.fallbackRouteParams\n\n        if (fallbackParams && fallbackParams.size > 0) {\n          // We are in a prerender with cacheComponents semantics. We are going to\n          // hang here and never resolve. This will cause the currently\n          // rendering component to effectively be a dynamic hole.\n          React.use(\n            makeHangingPromise(\n              workUnitStore.renderSignal,\n              workStore.route,\n              expression\n            )\n          )\n        }\n        break\n      }\n      case 'prerender-ppr': {\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        if (fallbackParams && fallbackParams.size > 0) {\n          return postponeWithTracking(\n            workStore.route,\n            expression,\n            workUnitStore.dynamicTracking\n          )\n        }\n        break\n      }\n      case 'prerender-runtime':\n        throw new InvariantError(\n          `\\`${expression}\\` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n        )\n      case 'cache':\n      case 'private-cache':\n        throw new InvariantError(\n          `\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n        )\n      case 'prerender-legacy':\n      case 'request':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n\nexport function useDynamicSearchParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (!workStore) {\n    // We assume pages router context and just return\n    return\n  }\n\n  if (!workUnitStore) {\n    throwForMissingRequestStore(expression)\n  }\n\n  switch (workUnitStore.type) {\n    case 'prerender-client': {\n      React.use(\n        makeHangingPromise(\n          workUnitStore.renderSignal,\n          workStore.route,\n          expression\n        )\n      )\n      break\n    }\n    case 'prerender-legacy':\n    case 'prerender-ppr': {\n      if (workStore.forceStatic) {\n        return\n      }\n      throw new BailoutToCSRError(expression)\n    }\n    case 'prerender':\n    case 'prerender-runtime':\n      throw new InvariantError(\n        `\\`${expression}\\` was called from a Server Component. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n      )\n    case 'cache':\n    case 'unstable-cache':\n    case 'private-cache':\n      throw new InvariantError(\n        `\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n      )\n    case 'request':\n      return\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/\n\n// Common implicit body tags that React will treat as body when placed directly in html\nconst bodyAndImplicitTags =\n  'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6'\n\n// Detects when RootLayoutBoundary (our framework marker component) appears\n// after Suspense in the component stack, indicating the root layout is wrapped\n// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.\n//\n// Example matches:\n//   at Suspense (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\n//\n// Or with other components in between (but not body/html/implicit-body):\n//   at Suspense (<anonymous>)\n//   at SomeComponent (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\nconst hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = new RegExp(\n  `\\\\n\\\\s+at Suspense \\\\(<anonymous>\\\\)(?:(?!\\\\n\\\\s+at (?:${bodyAndImplicitTags}) \\\\(<anonymous>\\\\))[\\\\s\\\\S])*?\\\\n\\\\s+at ${ROOT_LAYOUT_BOUNDARY_NAME} \\\\([^\\\\n]*\\\\)`\n)\n\nconst hasMetadataRegex = new RegExp(\n  `\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasViewportRegex = new RegExp(\n  `\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`)\n\nexport function trackAllowedDynamicAccess(\n  workStore: WorkStore,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicMetadata = true\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicViewport = true\n    return\n  } else if (\n    hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(\n      componentStack\n    )\n  ) {\n    // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\n    // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\n    // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\n    dynamicValidation.hasAllowedDynamic = true\n    dynamicValidation.hasSuspenseAboveBody = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    // this error had a Suspense boundary above it so we don't need to report it as a source\n    // of disallowed\n    dynamicValidation.hasAllowedDynamic = true\n    return\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    // This task was the task that called the sync error.\n    dynamicValidation.dynamicErrors.push(\n      clientDynamic.syncDynamicErrorWithStack\n    )\n    return\n  } else {\n    const message =\n      `Route \"${workStore.route}\": Uncached data was accessed outside of ` +\n      '<Suspense>. This delays the entire page from rendering, resulting in a ' +\n      'slow user experience. Learn more: ' +\n      'https://nextjs.org/docs/messages/blocking-route'\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\n/**\n * In dev mode, we prefer using the owner stack, otherwise the provided\n * component stack is used.\n */\nfunction createErrorWithComponentOrOwnerStack(\n  message: string,\n  componentStack: string\n) {\n  const ownerStack =\n    process.env.NODE_ENV !== 'production' && React.captureOwnerStack\n      ? React.captureOwnerStack()\n      : null\n\n  const error = new Error(message)\n  error.stack = error.name + ': ' + message + (ownerStack ?? componentStack)\n  return error\n}\n\nexport enum PreludeState {\n  Full = 0,\n  Empty = 1,\n  Errored = 2,\n}\n\nexport function logDisallowedDynamicError(\n  workStore: WorkStore,\n  error: Error\n): void {\n  console.error(error)\n\n  if (!workStore.dev) {\n    if (workStore.hasReadableErrorStacks) {\n      console.error(\n        `To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.`\n      )\n    } else {\n      console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:\n  - Start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.\n  - Rerun the production build with \\`next build --debug-prerender\\` to generate better stack traces.`)\n    }\n  }\n}\n\nexport function throwIfDisallowedDynamic(\n  workStore: WorkStore,\n  prelude: PreludeState,\n  dynamicValidation: DynamicValidationState,\n  serverDynamic: DynamicTrackingState\n): void {\n  if (serverDynamic.syncDynamicErrorWithStack) {\n    logDisallowedDynamicError(\n      workStore,\n      serverDynamic.syncDynamicErrorWithStack\n    )\n    throw new StaticGenBailoutError()\n  }\n\n  if (prelude !== PreludeState.Full) {\n    if (dynamicValidation.hasSuspenseAboveBody) {\n      // This route has opted into allowing fully dynamic rendering\n      // by including a Suspense boundary above the body. In this case\n      // a lack of a shell is not considered disallowed so we simply return\n      return\n    }\n\n    // We didn't have any sync bailouts but there may be user code which\n    // blocked the root. We would have captured these during the prerender\n    // and can log them here and then terminate the build/validating render\n    const dynamicErrors = dynamicValidation.dynamicErrors\n    if (dynamicErrors.length > 0) {\n      for (let i = 0; i < dynamicErrors.length; i++) {\n        logDisallowedDynamicError(workStore, dynamicErrors[i])\n      }\n\n      throw new StaticGenBailoutError()\n    }\n\n    // If we got this far then the only other thing that could be blocking\n    // the root is dynamic Viewport. If this is dynamic then\n    // you need to opt into that by adding a Suspense boundary above the body\n    // to indicate your are ok with fully dynamic rendering.\n    if (dynamicValidation.hasDynamicViewport) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n      )\n      throw new StaticGenBailoutError()\n    }\n\n    if (prelude === PreludeState.Empty) {\n      // If we ever get this far then we messed up the tracking of invalid dynamic.\n      // We still adhere to the constraint that you must produce a shell but invite the\n      // user to report this as a bug in Next.js.\n      console.error(\n        `Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`\n      )\n      throw new StaticGenBailoutError()\n    }\n  } else {\n    if (\n      dynamicValidation.hasAllowedDynamic === false &&\n      dynamicValidation.hasDynamicMetadata\n    ) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`\n      )\n      throw new StaticGenBailoutError()\n    }\n  }\n}\n\nexport function delayUntilRuntimeStage<T>(\n  prerenderStore: PrerenderStoreModernRuntime,\n  result: Promise<T>\n): Promise<T> {\n  if (prerenderStore.runtimeStagePromise) {\n    return prerenderStore.runtimeStagePromise.then(() => result)\n  }\n  return result\n}\n","export {\n  RequestCookies,\n  ResponseCookies,\n  stringifyCookie,\n} from 'next/dist/compiled/@edge-runtime/cookies'\n","export class ReflectAdapter {\n  static get<T extends object>(\n    target: T,\n    prop: string | symbol,\n    receiver: unknown\n  ): any {\n    const value = Reflect.get(target, prop, receiver)\n    if (typeof value === 'function') {\n      return value.bind(target)\n    }\n\n    return value\n  }\n\n  static set<T extends object>(\n    target: T,\n    prop: string | symbol,\n    value: any,\n    receiver: any\n  ): boolean {\n    return Reflect.set(target, prop, value, receiver)\n  }\n\n  static has<T extends object>(target: T, prop: string | symbol): boolean {\n    return Reflect.has(target, prop)\n  }\n\n  static deleteProperty<T extends object>(\n    target: T,\n    prop: string | symbol\n  ): boolean {\n    return Reflect.deleteProperty(target, prop)\n  }\n}\n","import { RequestCookies } from '../cookies'\n\nimport { ResponseCookies } from '../cookies'\nimport { ReflectAdapter } from './reflect'\nimport { workAsyncStorage } from '../../../app-render/work-async-storage.external'\nimport type { RequestStore } from '../../../app-render/work-unit-async-storage.external'\n\n/**\n * @internal\n */\nexport class ReadonlyRequestCookiesError extends Error {\n  constructor() {\n    super(\n      'Cookies can only be modified in a Server Action or Route Handler. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#options'\n    )\n  }\n\n  public static callable() {\n    throw new ReadonlyRequestCookiesError()\n  }\n}\n\n// We use this to type some APIs but we don't construct instances directly\nexport type { ResponseCookies }\n\n// The `cookies()` API is a mix of request and response cookies. For `.get()` methods,\n// we want to return the request cookie if it exists. For mutative methods like `.set()`,\n// we want to return the response cookie.\nexport type ReadonlyRequestCookies = Omit<\n  RequestCookies,\n  'set' | 'clear' | 'delete'\n> &\n  Pick<ResponseCookies, 'set' | 'delete'>\n\nexport class RequestCookiesAdapter {\n  public static seal(cookies: RequestCookies): ReadonlyRequestCookies {\n    return new Proxy(cookies as any, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case 'clear':\n          case 'delete':\n          case 'set':\n            return ReadonlyRequestCookiesError.callable\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n  }\n}\n\nconst SYMBOL_MODIFY_COOKIE_VALUES = Symbol.for('next.mutated.cookies')\n\nexport function getModifiedCookieValues(\n  cookies: ResponseCookies\n): ResponseCookie[] {\n  const modified: ResponseCookie[] | undefined = (cookies as unknown as any)[\n    SYMBOL_MODIFY_COOKIE_VALUES\n  ]\n  if (!modified || !Array.isArray(modified) || modified.length === 0) {\n    return []\n  }\n\n  return modified\n}\n\ntype SetCookieArgs =\n  | [key: string, value: string, cookie?: Partial<ResponseCookie>]\n  | [options: ResponseCookie]\n\nexport function appendMutableCookies(\n  headers: Headers,\n  mutableCookies: ResponseCookies\n): boolean {\n  const modifiedCookieValues = getModifiedCookieValues(mutableCookies)\n  if (modifiedCookieValues.length === 0) {\n    return false\n  }\n\n  // Return a new response that extends the response with\n  // the modified cookies as fallbacks. `res` cookies\n  // will still take precedence.\n  const resCookies = new ResponseCookies(headers)\n  const returnedCookies = resCookies.getAll()\n\n  // Set the modified cookies as fallbacks.\n  for (const cookie of modifiedCookieValues) {\n    resCookies.set(cookie)\n  }\n\n  // Set the original cookies as the final values.\n  for (const cookie of returnedCookies) {\n    resCookies.set(cookie)\n  }\n\n  return true\n}\n\ntype ResponseCookie = NonNullable<\n  ReturnType<InstanceType<typeof ResponseCookies>['get']>\n>\n\nexport class MutableRequestCookiesAdapter {\n  public static wrap(\n    cookies: RequestCookies,\n    onUpdateCookies?: (cookies: string[]) => void\n  ): ResponseCookies {\n    const responseCookies = new ResponseCookies(new Headers())\n    for (const cookie of cookies.getAll()) {\n      responseCookies.set(cookie)\n    }\n\n    let modifiedValues: ResponseCookie[] = []\n    const modifiedCookies = new Set<string>()\n    const updateResponseCookies = () => {\n      // TODO-APP: change method of getting workStore\n      const workStore = workAsyncStorage.getStore()\n      if (workStore) {\n        workStore.pathWasRevalidated = true\n      }\n\n      const allCookies = responseCookies.getAll()\n      modifiedValues = allCookies.filter((c) => modifiedCookies.has(c.name))\n      if (onUpdateCookies) {\n        const serializedCookies: string[] = []\n        for (const cookie of modifiedValues) {\n          const tempCookies = new ResponseCookies(new Headers())\n          tempCookies.set(cookie)\n          serializedCookies.push(tempCookies.toString())\n        }\n\n        onUpdateCookies(serializedCookies)\n      }\n    }\n\n    const wrappedCookies = new Proxy(responseCookies, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          // A special symbol to get the modified cookie values\n          case SYMBOL_MODIFY_COOKIE_VALUES:\n            return modifiedValues\n\n          // TODO: Throw error if trying to set a cookie after the response\n          // headers have been set.\n          case 'delete':\n            return function (...args: [string] | [ResponseCookie]) {\n              modifiedCookies.add(\n                typeof args[0] === 'string' ? args[0] : args[0].name\n              )\n              try {\n                target.delete(...args)\n                return wrappedCookies\n              } finally {\n                updateResponseCookies()\n              }\n            }\n          case 'set':\n            return function (...args: SetCookieArgs) {\n              modifiedCookies.add(\n                typeof args[0] === 'string' ? args[0] : args[0].name\n              )\n              try {\n                target.set(...args)\n                return wrappedCookies\n              } finally {\n                updateResponseCookies()\n              }\n            }\n\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n\n    return wrappedCookies\n  }\n}\n\nexport function createCookiesWithMutableAccessCheck(\n  requestStore: RequestStore\n): ResponseCookies {\n  const wrappedCookies = new Proxy(requestStore.mutableCookies, {\n    get(target, prop, receiver) {\n      switch (prop) {\n        case 'delete':\n          return function (...args: [string] | [ResponseCookie]) {\n            ensureCookiesAreStillMutable(requestStore, 'cookies().delete')\n            target.delete(...args)\n            return wrappedCookies\n          }\n        case 'set':\n          return function (...args: SetCookieArgs) {\n            ensureCookiesAreStillMutable(requestStore, 'cookies().set')\n            target.set(...args)\n            return wrappedCookies\n          }\n\n        default:\n          return ReflectAdapter.get(target, prop, receiver)\n      }\n    },\n  })\n  return wrappedCookies\n}\n\nexport function areCookiesMutableInCurrentPhase(requestStore: RequestStore) {\n  return requestStore.phase === 'action'\n}\n\n/** Ensure that cookies() starts throwing on mutation\n * if we changed phases and can no longer mutate.\n *\n * This can happen when going:\n *   'render' -> 'after'\n *   'action' -> 'render'\n * */\nfunction ensureCookiesAreStillMutable(\n  requestStore: RequestStore,\n  _callingExpression: string\n) {\n  if (!areCookiesMutableInCurrentPhase(requestStore)) {\n    // TODO: maybe we can give a more precise error message based on callingExpression?\n    throw new ReadonlyRequestCookiesError()\n  }\n}\n\nexport function responseCookiesToRequestCookies(\n  responseCookies: ResponseCookies\n): RequestCookies {\n  const requestCookies = new RequestCookies(new Headers())\n  for (const cookie of responseCookies.getAll()) {\n    requestCookies.set(cookie)\n  }\n  return requestCookies\n}\n","import * as React from 'react'\n\nconst errorRef: { current: null | Error } = { current: null }\n\n// React.cache is currently only available in canary/experimental React channels.\nconst cache =\n  typeof React.cache === 'function'\n    ? React.cache\n    : (fn: (key: unknown) => void) => fn\n\n// When Cache Components is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn = process.env.__NEXT_CACHE_COMPONENTS\n  ? console.error\n  : console.warn\n\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\n  (key: unknown) => {\n    try {\n      logErrorOrWarn(errorRef.current)\n    } finally {\n      errorRef.current = null\n    }\n  }\n)\n\n/**\n * Creates a function that logs an error message that is deduped by the userland\n * callsite.\n * This requires no indirection between the call of this function and the userland\n * callsite i.e. there's only a single library frame above this.\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\n * Only use that for warnings need a fix independent of the callstack.\n *\n * @param getMessage\n * @returns\n */\nexport function createDedupedByCallsiteServerErrorLoggerDev<Args extends any[]>(\n  getMessage: (...args: Args) => Error\n) {\n  return function logDedupedError(...args: Args) {\n    const message = getMessage(...args)\n\n    if (process.env.NODE_ENV !== 'production') {\n      const callStackFrames = new Error().stack?.split('\\n')\n      if (callStackFrames === undefined || callStackFrames.length < 4) {\n        logErrorOrWarn(message)\n      } else {\n        // Error:\n        //   logDedupedError\n        //   asyncApiBeingAccessedSynchronously\n        //   <userland callsite>\n        // TODO: This breaks if sourcemaps with ignore lists are enabled.\n        const key = callStackFrames[4]\n        errorRef.current = message\n        flushCurrentErrorIfNew(key)\n      }\n    } else {\n      logErrorOrWarn(message)\n    }\n  }\n}\n","import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external'\nimport type { WorkStore } from '../app-render/work-async-storage.external'\n\nexport function throwWithStaticGenerationBailoutErrorWithDynamicError(\n  route: string,\n  expression: string\n): never {\n  throw new StaticGenBailoutError(\n    `Route ${route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n  )\n}\n\nexport function throwForSearchParamsAccessInUseCache(\n  workStore: WorkStore,\n  constructorOpt: Function\n): never {\n  const error = new Error(\n    `Route ${workStore.route} used \\`searchParams\\` inside \"use cache\". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \\`searchParams\\` outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n  )\n\n  Error.captureStackTrace(error, constructorOpt)\n  workStore.invalidDynamicUsageError ??= error\n\n  throw error\n}\n\nexport function isRequestAPICallableInsideAfter() {\n  const afterTaskStore = afterTaskAsyncStorage.getStore()\n  return afterTaskStore?.rootTaskSpawnPhase === 'action'\n}\n","import {\n  type ReadonlyRequestCookies,\n  areCookiesMutableInCurrentPhase,\n  RequestCookiesAdapter,\n} from '../web/spec-extension/adapters/request-cookies'\nimport { RequestCookies } from '../web/spec-extension/cookies'\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport {\n  throwForMissingRequestStore,\n  workUnitAsyncStorage,\n  type PrerenderStoreModern,\n  type RequestStore,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  delayUntilRuntimeStage,\n  postponeWithTracking,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n} from '../app-render/dynamic-rendering'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { isRequestAPICallableInsideAfter } from './utils'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { RenderStage } from '../app-render/staged-rendering'\n\nexport function cookies(): Promise<ReadonlyRequestCookies> {\n  const callingExpression = 'cookies'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (\n      workUnitStore &&\n      workUnitStore.phase === 'after' &&\n      !isRequestAPICallableInsideAfter()\n    ) {\n      throw new Error(\n        // TODO(after): clarify that this only applies to pages?\n        `Route ${workStore.route} used \\`cookies()\\` inside \\`after()\\`. This is not supported. If you need this data inside an \\`after()\\` callback, use \\`cookies()\\` outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // cookies object without tracking\n      const underlyingCookies = createEmptyCookies()\n      return makeUntrackedCookies(underlyingCookies)\n    }\n\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies()\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'cache':\n          const error = new Error(\n            `Route ${workStore.route} used \\`cookies()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`cookies()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n          )\n          Error.captureStackTrace(error, cookies)\n          workStore.invalidDynamicUsageError ??= error\n          throw error\n        case 'unstable-cache':\n          throw new Error(\n            `Route ${workStore.route} used \\`cookies()\\` inside a function cached with \\`unstable_cache()\\`. Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`cookies()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n          )\n        case 'prerender':\n          return makeHangingCookies(workStore, workUnitStore)\n        case 'prerender-client':\n          const exportName = '`cookies`'\n          throw new InvariantError(\n            `${exportName} must not be used within a Client Component. Next.js should be preventing ${exportName} from being included in Client Components statically, but did not in this case.`\n          )\n        case 'prerender-ppr':\n          // We need track dynamic access here eagerly to keep continuity with\n          // how cookies has worked in PPR without cacheComponents.\n          return postponeWithTracking(\n            workStore.route,\n            callingExpression,\n            workUnitStore.dynamicTracking\n          )\n        case 'prerender-legacy':\n          // We track dynamic access here so we don't need to wrap the cookies\n          // in individual property access tracking.\n          return throwToInterruptStaticGeneration(\n            callingExpression,\n            workStore,\n            workUnitStore\n          )\n        case 'prerender-runtime':\n          return delayUntilRuntimeStage(\n            workUnitStore,\n            makeUntrackedCookies(workUnitStore.cookies)\n          )\n        case 'private-cache':\n          // Private caches are delayed until the runtime stage in use-cache-wrapper,\n          // so we don't need an additional delay here.\n          return makeUntrackedCookies(workUnitStore.cookies)\n        case 'request':\n          trackDynamicDataInDynamicRender(workUnitStore)\n\n          let underlyingCookies: ReadonlyRequestCookies\n\n          if (areCookiesMutableInCurrentPhase(workUnitStore)) {\n            // We can't conditionally return different types here based on the context.\n            // To avoid confusion, we always return the readonly type here.\n            underlyingCookies =\n              workUnitStore.userspaceMutableCookies as unknown as ReadonlyRequestCookies\n          } else {\n            underlyingCookies = workUnitStore.cookies\n          }\n\n          if (process.env.NODE_ENV === 'development') {\n            // Semantically we only need the dev tracking when running in `next dev`\n            // but since you would never use next dev with production NODE_ENV we use this\n            // as a proxy so we can statically exclude this code from production builds.\n            return makeUntrackedCookiesWithDevWarnings(\n              workUnitStore,\n              underlyingCookies,\n              workStore?.route\n            )\n          } else {\n            return makeUntrackedCookies(underlyingCookies)\n          }\n        default:\n          workUnitStore satisfies never\n      }\n    }\n  }\n\n  // If we end up here, there was no work store or work unit store present.\n  throwForMissingRequestStore(callingExpression)\n}\n\nfunction createEmptyCookies(): ReadonlyRequestCookies {\n  return RequestCookiesAdapter.seal(new RequestCookies(new Headers({})))\n}\n\ninterface CacheLifetime {}\nconst CachedCookies = new WeakMap<\n  CacheLifetime,\n  Promise<ReadonlyRequestCookies>\n>()\n\nfunction makeHangingCookies(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreModern\n): Promise<ReadonlyRequestCookies> {\n  const cachedPromise = CachedCookies.get(prerenderStore)\n  if (cachedPromise) {\n    return cachedPromise\n  }\n\n  const promise = makeHangingPromise<ReadonlyRequestCookies>(\n    prerenderStore.renderSignal,\n    workStore.route,\n    '`cookies()`'\n  )\n  CachedCookies.set(prerenderStore, promise)\n\n  return promise\n}\n\nfunction makeUntrackedCookies(\n  underlyingCookies: ReadonlyRequestCookies\n): Promise<ReadonlyRequestCookies> {\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = Promise.resolve(underlyingCookies)\n  CachedCookies.set(underlyingCookies, promise)\n\n  return promise\n}\n\nfunction makeUntrackedCookiesWithDevWarnings(\n  requestStore: RequestStore,\n  underlyingCookies: ReadonlyRequestCookies,\n  route?: string\n): Promise<ReadonlyRequestCookies> {\n  if (requestStore.asyncApiPromises) {\n    let promise: Promise<ReadonlyRequestCookies>\n    if (underlyingCookies === requestStore.mutableCookies) {\n      promise = requestStore.asyncApiPromises.mutableCookies\n    } else if (underlyingCookies === requestStore.cookies) {\n      promise = requestStore.asyncApiPromises.cookies\n    } else {\n      throw new InvariantError(\n        'Received an underlying cookies object that does not match either `cookies` or `mutableCookies`'\n      )\n    }\n    return instrumentCookiesPromiseWithDevWarnings(promise, route)\n  }\n\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = makeDevtoolsIOAwarePromise(\n    underlyingCookies,\n    requestStore,\n    RenderStage.Runtime\n  )\n\n  const proxiedPromise = instrumentCookiesPromiseWithDevWarnings(promise, route)\n\n  CachedCookies.set(underlyingCookies, proxiedPromise)\n\n  return proxiedPromise\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createCookiesAccessError\n)\n\nfunction instrumentCookiesPromiseWithDevWarnings(\n  promise: Promise<ReadonlyRequestCookies>,\n  route: string | undefined\n) {\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: replaceableWarningDescriptorForSymbolIterator(\n      promise,\n      route\n    ),\n    size: replaceableWarningDescriptor(promise, 'size', route),\n    get: replaceableWarningDescriptor(promise, 'get', route),\n    getAll: replaceableWarningDescriptor(promise, 'getAll', route),\n    has: replaceableWarningDescriptor(promise, 'has', route),\n    set: replaceableWarningDescriptor(promise, 'set', route),\n    delete: replaceableWarningDescriptor(promise, 'delete', route),\n    clear: replaceableWarningDescriptor(promise, 'clear', route),\n    toString: replaceableWarningDescriptor(promise, 'toString', route),\n  })\n  return promise\n}\n\nfunction replaceableWarningDescriptor(\n  target: unknown,\n  prop: string,\n  route: string | undefined\n) {\n  return {\n    enumerable: false,\n    get() {\n      warnForSyncAccess(route, `\\`cookies().${prop}\\``)\n      return undefined\n    },\n    set(value: unknown) {\n      Object.defineProperty(target, prop, {\n        value,\n        writable: true,\n        configurable: true,\n      })\n    },\n    configurable: true,\n  }\n}\n\nfunction replaceableWarningDescriptorForSymbolIterator(\n  target: unknown,\n  route: string | undefined\n) {\n  return {\n    enumerable: false,\n    get() {\n      warnForSyncAccess(route, '`...cookies()` or similar iteration')\n      return undefined\n    },\n    set(value: unknown) {\n      Object.defineProperty(target, Symbol.iterator, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true,\n      })\n    },\n    configurable: true,\n  }\n}\n\nfunction createCookiesAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`cookies()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n","import type { IncomingHttpHeaders } from 'http'\n\nimport { ReflectAdapter } from './reflect'\n\n/**\n * @internal\n */\nexport class ReadonlyHeadersError extends Error {\n  constructor() {\n    super(\n      'Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers'\n    )\n  }\n\n  public static callable() {\n    throw new ReadonlyHeadersError()\n  }\n}\n\nexport type ReadonlyHeaders = Headers & {\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  append(...args: any[]): void\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  set(...args: any[]): void\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  delete(...args: any[]): void\n}\nexport class HeadersAdapter extends Headers {\n  private readonly headers: IncomingHttpHeaders\n\n  constructor(headers: IncomingHttpHeaders) {\n    // We've already overridden the methods that would be called, so we're just\n    // calling the super constructor to ensure that the instanceof check works.\n    super()\n\n    this.headers = new Proxy(headers, {\n      get(target, prop, receiver) {\n        // Because this is just an object, we expect that all \"get\" operations\n        // are for properties. If it's a \"get\" for a symbol, we'll just return\n        // the symbol.\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return undefined.\n        if (typeof original === 'undefined') return\n\n        // If the original casing exists, return the value.\n        return ReflectAdapter.get(target, original, receiver)\n      },\n      set(target, prop, value, receiver) {\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.set(target, prop, value, receiver)\n        }\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, use the prop as the key.\n        return ReflectAdapter.set(target, original ?? prop, value, receiver)\n      },\n      has(target, prop) {\n        if (typeof prop === 'symbol') return ReflectAdapter.has(target, prop)\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return false.\n        if (typeof original === 'undefined') return false\n\n        // If the original casing exists, return true.\n        return ReflectAdapter.has(target, original)\n      },\n      deleteProperty(target, prop) {\n        if (typeof prop === 'symbol')\n          return ReflectAdapter.deleteProperty(target, prop)\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return true.\n        if (typeof original === 'undefined') return true\n\n        // If the original casing exists, delete the property.\n        return ReflectAdapter.deleteProperty(target, original)\n      },\n    })\n  }\n\n  /**\n   * Seals a Headers instance to prevent modification by throwing an error when\n   * any mutating method is called.\n   */\n  public static seal(headers: Headers): ReadonlyHeaders {\n    return new Proxy<ReadonlyHeaders>(headers, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case 'append':\n          case 'delete':\n          case 'set':\n            return ReadonlyHeadersError.callable\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n  }\n\n  /**\n   * Merges a header value into a string. This stores multiple values as an\n   * array, so we need to merge them into a string.\n   *\n   * @param value a header value\n   * @returns a merged header value (a string)\n   */\n  private merge(value: string | string[]): string {\n    if (Array.isArray(value)) return value.join(', ')\n\n    return value\n  }\n\n  /**\n   * Creates a Headers instance from a plain object or a Headers instance.\n   *\n   * @param headers a plain object or a Headers instance\n   * @returns a headers instance\n   */\n  public static from(headers: IncomingHttpHeaders | Headers): Headers {\n    if (headers instanceof Headers) return headers\n\n    return new HeadersAdapter(headers)\n  }\n\n  public append(name: string, value: string): void {\n    const existing = this.headers[name]\n    if (typeof existing === 'string') {\n      this.headers[name] = [existing, value]\n    } else if (Array.isArray(existing)) {\n      existing.push(value)\n    } else {\n      this.headers[name] = value\n    }\n  }\n\n  public delete(name: string): void {\n    delete this.headers[name]\n  }\n\n  public get(name: string): string | null {\n    const value = this.headers[name]\n    if (typeof value !== 'undefined') return this.merge(value)\n\n    return null\n  }\n\n  public has(name: string): boolean {\n    return typeof this.headers[name] !== 'undefined'\n  }\n\n  public set(name: string, value: string): void {\n    this.headers[name] = value\n  }\n\n  public forEach(\n    callbackfn: (value: string, name: string, parent: Headers) => void,\n    thisArg?: any\n  ): void {\n    for (const [name, value] of this.entries()) {\n      callbackfn.call(thisArg, value, name, this)\n    }\n  }\n\n  public *entries(): HeadersIterator<[string, string]> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(name) as string\n\n      yield [name, value] as [string, string]\n    }\n  }\n\n  public *keys(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      yield name\n    }\n  }\n\n  public *values(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(key) as string\n\n      yield value\n    }\n  }\n\n  public [Symbol.iterator](): HeadersIterator<[string, string]> {\n    return this.entries()\n  }\n}\n","import {\n  HeadersAdapter,\n  type ReadonlyHeaders,\n} from '../web/spec-extension/adapters/headers'\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport {\n  throwForMissingRequestStore,\n  workUnitAsyncStorage,\n  type PrerenderStoreModern,\n  type RequestStore,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  delayUntilRuntimeStage,\n  postponeWithTracking,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n} from '../app-render/dynamic-rendering'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { isRequestAPICallableInsideAfter } from './utils'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { RenderStage } from '../app-render/staged-rendering'\n\n/**\n * This function allows you to read the HTTP incoming request headers in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers) and\n * [Middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware).\n *\n * Read more: [Next.js Docs: `headers`](https://nextjs.org/docs/app/api-reference/functions/headers)\n */\nexport function headers(): Promise<ReadonlyHeaders> {\n  const callingExpression = 'headers'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (\n      workUnitStore &&\n      workUnitStore.phase === 'after' &&\n      !isRequestAPICallableInsideAfter()\n    ) {\n      throw new Error(\n        `Route ${workStore.route} used \\`headers()\\` inside \\`after()\\`. This is not supported. If you need this data inside an \\`after()\\` callback, use \\`headers()\\` outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // headers object without tracking\n      const underlyingHeaders = HeadersAdapter.seal(new Headers({}))\n      return makeUntrackedHeaders(underlyingHeaders)\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'cache': {\n          const error = new Error(\n            `Route ${workStore.route} used \\`headers()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`headers()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n          )\n          Error.captureStackTrace(error, headers)\n          workStore.invalidDynamicUsageError ??= error\n          throw error\n        }\n        case 'unstable-cache':\n          throw new Error(\n            `Route ${workStore.route} used \\`headers()\\` inside a function cached with \\`unstable_cache()\\`. Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`headers()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n          )\n        case 'prerender':\n        case 'prerender-client':\n        case 'private-cache':\n        case 'prerender-runtime':\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'request':\n          break\n        default:\n          workUnitStore satisfies never\n      }\n    }\n\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers()\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'prerender':\n          return makeHangingHeaders(workStore, workUnitStore)\n        case 'prerender-client':\n          const exportName = '`headers`'\n          throw new InvariantError(\n            `${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`\n          )\n        case 'prerender-ppr':\n          // PPR Prerender (no cacheComponents)\n          // We are prerendering with PPR. We need track dynamic access here eagerly\n          // to keep continuity with how headers has worked in PPR without cacheComponents.\n          // TODO consider switching the semantic to throw on property access instead\n          return postponeWithTracking(\n            workStore.route,\n            callingExpression,\n            workUnitStore.dynamicTracking\n          )\n        case 'prerender-legacy':\n          // Legacy Prerender\n          // We are in a legacy static generation mode while prerendering\n          // We track dynamic access here so we don't need to wrap the headers in\n          // individual property access tracking.\n          return throwToInterruptStaticGeneration(\n            callingExpression,\n            workStore,\n            workUnitStore\n          )\n        case 'prerender-runtime':\n          return delayUntilRuntimeStage(\n            workUnitStore,\n            makeUntrackedHeaders(workUnitStore.headers)\n          )\n        case 'private-cache':\n          // Private caches are delayed until the runtime stage in use-cache-wrapper,\n          // so we don't need an additional delay here.\n          return makeUntrackedHeaders(workUnitStore.headers)\n        case 'request':\n          trackDynamicDataInDynamicRender(workUnitStore)\n\n          if (process.env.NODE_ENV === 'development') {\n            // Semantically we only need the dev tracking when running in `next dev`\n            // but since you would never use next dev with production NODE_ENV we use this\n            // as a proxy so we can statically exclude this code from production builds.\n            return makeUntrackedHeadersWithDevWarnings(\n              workUnitStore.headers,\n              workStore?.route,\n              workUnitStore\n            )\n          } else {\n            return makeUntrackedHeaders(workUnitStore.headers)\n          }\n          break\n        default:\n          workUnitStore satisfies never\n      }\n    }\n  }\n\n  // If we end up here, there was no work store or work unit store present.\n  throwForMissingRequestStore(callingExpression)\n}\n\ninterface CacheLifetime {}\nconst CachedHeaders = new WeakMap<CacheLifetime, Promise<ReadonlyHeaders>>()\n\nfunction makeHangingHeaders(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreModern\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(prerenderStore)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = makeHangingPromise<ReadonlyHeaders>(\n    prerenderStore.renderSignal,\n    workStore.route,\n    '`headers()`'\n  )\n  CachedHeaders.set(prerenderStore, promise)\n\n  return promise\n}\n\nfunction makeUntrackedHeaders(\n  underlyingHeaders: ReadonlyHeaders\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = Promise.resolve(underlyingHeaders)\n  CachedHeaders.set(underlyingHeaders, promise)\n\n  return promise\n}\n\nfunction makeUntrackedHeadersWithDevWarnings(\n  underlyingHeaders: ReadonlyHeaders,\n  route: string | undefined,\n  requestStore: RequestStore\n): Promise<ReadonlyHeaders> {\n  if (requestStore.asyncApiPromises) {\n    const promise = requestStore.asyncApiPromises.headers\n    return instrumentHeadersPromiseWithDevWarnings(promise, route)\n  }\n\n  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = makeDevtoolsIOAwarePromise(\n    underlyingHeaders,\n    requestStore,\n    RenderStage.Runtime\n  )\n\n  const proxiedPromise = instrumentHeadersPromiseWithDevWarnings(promise, route)\n\n  CachedHeaders.set(underlyingHeaders, proxiedPromise)\n\n  return proxiedPromise\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createHeadersAccessError\n)\n\nfunction instrumentHeadersPromiseWithDevWarnings(\n  promise: Promise<ReadonlyHeaders>,\n  route: string | undefined\n) {\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: replaceableWarningDescriptorForSymbolIterator(\n      promise,\n      route\n    ),\n    append: replaceableWarningDescriptor(promise, 'append', route),\n    delete: replaceableWarningDescriptor(promise, 'delete', route),\n    get: replaceableWarningDescriptor(promise, 'get', route),\n    has: replaceableWarningDescriptor(promise, 'has', route),\n    set: replaceableWarningDescriptor(promise, 'set', route),\n    getSetCookie: replaceableWarningDescriptor(promise, 'getSetCookie', route),\n    forEach: replaceableWarningDescriptor(promise, 'forEach', route),\n    keys: replaceableWarningDescriptor(promise, 'keys', route),\n    values: replaceableWarningDescriptor(promise, 'values', route),\n    entries: replaceableWarningDescriptor(promise, 'entries', route),\n  })\n  return promise\n}\n\nfunction replaceableWarningDescriptor(\n  target: unknown,\n  prop: string,\n  route: string | undefined\n) {\n  return {\n    enumerable: false,\n    get() {\n      warnForSyncAccess(route, `\\`headers().${prop}\\``)\n      return undefined\n    },\n    set(value: unknown) {\n      Object.defineProperty(target, prop, {\n        value,\n        writable: true,\n        configurable: true,\n      })\n    },\n    configurable: true,\n  }\n}\n\nfunction replaceableWarningDescriptorForSymbolIterator(\n  target: unknown,\n  route: string | undefined\n) {\n  return {\n    enumerable: false,\n    get() {\n      warnForSyncAccess(route, '`...headers()` or similar iteration')\n      return undefined\n    },\n    set(value: unknown) {\n      Object.defineProperty(target, Symbol.iterator, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true,\n      })\n    },\n    configurable: true,\n  }\n}\n\nfunction createHeadersAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`headers()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n","import {\n  getDraftModeProviderForCacheScope,\n  throwForMissingRequestStore,\n} from '../app-render/work-unit-async-storage.external'\n\nimport type { DraftModeProvider } from '../async-storage/draft-mode-provider'\n\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\nimport {\n  abortAndThrowOnSynchronousRequestDataAccess,\n  delayUntilRuntimeStage,\n  postponeWithTracking,\n  trackDynamicDataInDynamicRender,\n} from '../app-render/dynamic-rendering'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\n\nexport function draftMode(): Promise<DraftMode> {\n  const callingExpression = 'draftMode'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (!workStore || !workUnitStore) {\n    throwForMissingRequestStore(callingExpression)\n  }\n\n  switch (workUnitStore.type) {\n    case 'prerender-runtime':\n      // TODO(runtime-ppr): does it make sense to delay this? normally it's always microtasky\n      return delayUntilRuntimeStage(\n        workUnitStore,\n        createOrGetCachedDraftMode(workUnitStore.draftMode, workStore)\n      )\n    case 'request':\n      return createOrGetCachedDraftMode(workUnitStore.draftMode, workStore)\n\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      // Inside of `\"use cache\"` or `unstable_cache`, draft mode is available if\n      // the outmost work unit store is a request store (or a runtime prerender),\n      // and if draft mode is enabled.\n      const draftModeProvider = getDraftModeProviderForCacheScope(\n        workStore,\n        workUnitStore\n      )\n\n      if (draftModeProvider) {\n        return createOrGetCachedDraftMode(draftModeProvider, workStore)\n      }\n\n    // Otherwise, we fall through to providing an empty draft mode.\n    // eslint-disable-next-line no-fallthrough\n    case 'prerender':\n    case 'prerender-client':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n      // Return empty draft mode\n      return createOrGetCachedDraftMode(null, workStore)\n\n    default:\n      return workUnitStore satisfies never\n  }\n}\n\nfunction createOrGetCachedDraftMode(\n  draftModeProvider: DraftModeProvider | null,\n  workStore: WorkStore | undefined\n): Promise<DraftMode> {\n  const cacheKey = draftModeProvider ?? NullDraftMode\n  const cachedDraftMode = CachedDraftModes.get(cacheKey)\n\n  if (cachedDraftMode) {\n    return cachedDraftMode\n  }\n\n  if (process.env.NODE_ENV === 'development' && !workStore?.isPrefetchRequest) {\n    const route = workStore?.route\n    return createDraftModeWithDevWarnings(draftModeProvider, route)\n  } else {\n    return Promise.resolve(new DraftMode(draftModeProvider))\n  }\n}\n\ninterface CacheLifetime {}\nconst NullDraftMode = {}\nconst CachedDraftModes = new WeakMap<CacheLifetime, Promise<DraftMode>>()\n\nfunction createDraftModeWithDevWarnings(\n  underlyingProvider: null | DraftModeProvider,\n  route: undefined | string\n): Promise<DraftMode> {\n  const instance = new DraftMode(underlyingProvider)\n  const promise = Promise.resolve(instance)\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      switch (prop) {\n        case 'isEnabled':\n          warnForSyncAccess(route, `\\`draftMode().${prop}\\``)\n          break\n        case 'enable':\n        case 'disable': {\n          warnForSyncAccess(route, `\\`draftMode().${prop}()\\``)\n          break\n        }\n        default: {\n          // We only warn for well-defined properties of the draftMode object.\n        }\n      }\n\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n  })\n\n  return proxiedPromise\n}\n\nclass DraftMode {\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private readonly _provider: null | DraftModeProvider\n\n  constructor(provider: null | DraftModeProvider) {\n    this._provider = provider\n  }\n  get isEnabled() {\n    if (this._provider !== null) {\n      return this._provider.isEnabled\n    }\n    return false\n  }\n  public enable() {\n    // We have a store we want to track dynamic data access to ensure we\n    // don't statically generate routes that manipulate draft mode.\n    trackDynamicDraftMode('draftMode().enable()', this.enable)\n    if (this._provider !== null) {\n      this._provider.enable()\n    }\n  }\n  public disable() {\n    trackDynamicDraftMode('draftMode().disable()', this.disable)\n    if (this._provider !== null) {\n      this._provider.disable()\n    }\n  }\n}\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createDraftModeAccessError\n)\n\nfunction createDraftModeAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`draftMode()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction trackDynamicDraftMode(expression: string, constructorOpt: Function) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    // We have a store we want to track dynamic data access to ensure we\n    // don't statically generate routes that manipulate draft mode.\n    if (workUnitStore?.phase === 'after') {\n      throw new Error(\n        `Route ${workStore.route} used \"${expression}\" inside \\`after()\\`. The enabled status of \\`draftMode()\\` can be read inside \\`after()\\` but you cannot enable or disable \\`draftMode()\\`. See more info here: https://nextjs.org/docs/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'cache':\n        case 'private-cache': {\n          const error = new Error(\n            `Route ${workStore.route} used \"${expression}\" inside \"use cache\". The enabled status of \\`draftMode()\\` can be read in caches but you must not enable or disable \\`draftMode()\\` inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n          )\n          Error.captureStackTrace(error, constructorOpt)\n          workStore.invalidDynamicUsageError ??= error\n          throw error\n        }\n        case 'unstable-cache':\n          throw new Error(\n            `Route ${workStore.route} used \"${expression}\" inside a function cached with \\`unstable_cache()\\`. The enabled status of \\`draftMode()\\` can be read in caches but you must not enable or disable \\`draftMode()\\` inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n          )\n\n        case 'prerender':\n        case 'prerender-runtime': {\n          const error = new Error(\n            `Route ${workStore.route} used ${expression} without first calling \\`await connection()\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-headers`\n          )\n          return abortAndThrowOnSynchronousRequestDataAccess(\n            workStore.route,\n            expression,\n            error,\n            workUnitStore\n          )\n        }\n        case 'prerender-client':\n          const exportName = '`draftMode`'\n          throw new InvariantError(\n            `${exportName} must not be used within a Client Component. Next.js should be preventing ${exportName} from being included in Client Components statically, but did not in this case.`\n          )\n        case 'prerender-ppr':\n          return postponeWithTracking(\n            workStore.route,\n            expression,\n            workUnitStore.dynamicTracking\n          )\n        case 'prerender-legacy':\n          workUnitStore.revalidate = 0\n\n          const err = new DynamicServerError(\n            `Route ${workStore.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n          )\n          workStore.dynamicUsageDescription = expression\n          workStore.dynamicUsageStack = err.stack\n\n          throw err\n        case 'request':\n          trackDynamicDataInDynamicRender(workUnitStore)\n          break\n        default:\n          workUnitStore satisfies never\n      }\n    }\n  }\n}\n","module.exports.cookies = require('./dist/server/request/cookies').cookies\nmodule.exports.headers = require('./dist/server/request/headers').headers\nmodule.exports.draftMode = require('./dist/server/request/draft-mode').draftMode\n","import { cookies } from \"next/headers\"\r\n\r\nexport type OperatorRole = \"admin\" | \"operator\" | \"auditor\"\r\n\r\nexport type OperatorSession = {\r\n  email: string\r\n  role: OperatorRole\r\n  ts: number\r\n}\r\n\r\nconst SESSION_COOKIE = \"operator_session\"\r\nconst SESSION_SECRET = process.env.OPERATOR_SESSION_SECRET || \"dev-operator-session-secret\"\r\n\r\nfunction textToUint8(data: string) {\r\n  return new TextEncoder().encode(data)\r\n}\r\n\r\nfunction base64UrlToUint8Array(b64url: string) {\r\n  const pad = \"=\".repeat((4 - (b64url.length % 4)) % 4)\r\n  const b64 = (b64url + pad).replace(/-/g, \"+\").replace(/_/g, \"/\")\r\n  const binary = atob(b64)\r\n  const bytes = new Uint8Array(binary.length)\r\n  for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i)\r\n  return bytes\r\n}\r\n\r\nfunction uint8ToHex(bytes: ArrayBuffer) {\r\n  const arr = new Uint8Array(bytes)\r\n  let hex = \"\"\r\n  for (let i = 0; i < arr.length; i++) {\r\n    hex += arr[i].toString(16).padStart(2, \"0\")\r\n  }\r\n  return hex\r\n}\r\n\r\nfunction safeEqual(a: string, b: string) {\r\n  if (a.length !== b.length) return false\r\n  let diff = 0\r\n  for (let i = 0; i < a.length; i++) {\r\n    diff |= a.charCodeAt(i) ^ b.charCodeAt(i)\r\n  }\r\n  return diff === 0\r\n}\r\n\r\nasync function importHmacKey(secret: string) {\r\n  return crypto.subtle.importKey(\"raw\", textToUint8(secret), { name: \"HMAC\", hash: \"SHA-256\" }, false, [\"sign\"])\r\n}\r\n\r\nexport async function decodeSession(token: string): Promise<OperatorSession | null> {\r\n  const [payloadB64, signature] = token.split(\".\")\r\n  if (!payloadB64 || !signature) return null\r\n\r\n  const key = await importHmacKey(SESSION_SECRET)\r\n  const expected = uint8ToHex(await crypto.subtle.sign(\"HMAC\", key, textToUint8(payloadB64)))\r\n  if (!safeEqual(signature, expected)) return null\r\n\r\n  try {\r\n    const payloadBytes = base64UrlToUint8Array(payloadB64)\r\n    const json = new TextDecoder().decode(payloadBytes)\r\n    const parsed = JSON.parse(json) as OperatorSession\r\n    return parsed\r\n  } catch (err) {\r\n    return null\r\n  }\r\n}\r\n\r\nexport async function verifyOperatorSession(): Promise<OperatorSession | null> {\r\n  const jar = await cookies()\r\n  const token = jar.get(SESSION_COOKIE)?.value\r\n  if (!token) return null\r\n  return decodeSession(token)\r\n}\r\n\r\nexport async function getSessionRoleFromCookie(): Promise<OperatorRole | null> {\r\n  const session = await verifyOperatorSession()\r\n  return session?.role ?? null\r\n}\r\n"],"names":["isHangingPromiseRejectionError","makeDevtoolsIOAwarePromise","makeHangingPromise","err","digest","HANGING_PROMISE_REJECTION","HangingPromiseRejectionError","Error","constructor","route","expression","abortListenersBySignal","WeakMap","signal","aborted","Promise","reject","hangingPromise","_","boundRejection","bind","currentListeners","get","push","listeners","set","addEventListener","i","length","once","catch","ignoreReject","underlying","requestStore","stage","stagedRendering","delayUntilStage","undefined","resolve","setTimeout","BailoutToCSRError","isBailoutToCSRError","BAILOUT_TO_CSR","reason","DynamicServerError","isDynamicServerError","DYNAMIC_ERROR_CODE","description","StaticGenBailoutError","isStaticGenBailoutError","NEXT_STATIC_GEN_BAILOUT","code","error","METADATA_BOUNDARY_NAME","OUTLET_BOUNDARY_NAME","ROOT_LAYOUT_BOUNDARY_NAME","VIEWPORT_BOUNDARY_NAME","atLeastOneTask","scheduleImmediate","scheduleOnNextTick","waitAtLeastOneReactRenderTask","cb","then","process","env","NEXT_RUNTIME","nextTick","setImmediate","r","InvariantError","message","options","endsWith","name","createPromiseWithResolvers","promise","res","rej","RenderStage","StagedRenderingController","abortSignal","currentStage","runtimeStagePromise","dynamicStagePromise","advanceStage","getStagePromise","waitForStage","displayName","resolvedValue","ioTriggerPromise","makeDevtoolsIOPromiseFromIOTrigger","ioTrigger","Postpone","PreludeState","abortAndThrowOnSynchronousRequestDataAccess","abortOnSynchronousPlatformIOAccess","accessedDynamicData","annotateDynamicAccess","consumeDynamicAccess","createDynamicTrackingState","createDynamicValidationState","createHangingInputAbortSignal","createRenderInBrowserAbortSignal","delayUntilRuntimeStage","formatDynamicAPIAccesses","getFirstDynamicReason","isDynamicPostpone","isPrerenderInterruptedError","logDisallowedDynamicError","markCurrentScopeAsDynamic","postponeWithTracking","throwIfDisallowedDynamic","throwToInterruptStaticGeneration","trackAllowedDynamicAccess","trackDynamicDataInDynamicRender","trackSynchronousPlatformIOAccessInDev","useDynamicRouteParams","useDynamicSearchParams","hasPostpone","React","unstable_postpone","isDebugDynamicAccesses","dynamicAccesses","syncDynamicErrorWithStack","hasSuspenseAboveBody","hasDynamicMetadata","hasDynamicViewport","hasAllowedDynamic","dynamicErrors","trackingState","store","workUnitStore","type","forceDynamic","forceStatic","dynamicShouldError","dynamicTracking","revalidate","dynamicUsageDescription","dynamicUsageStack","stack","NODE_ENV","usedDynamic","prerenderStore","abortOnSynchronousDynamicDataAccess","createPrerenderInterruptedError","controller","abort","errorWithStack","Dynamic","prerenderSignal","workUnitAsyncStorage","getStore","assertPostpone","createPostponeReason","isDynamicPostponeReason","includes","NEXT_PRERENDER_INTERRUPTED","serverDynamic","clientDynamic","filter","access","map","split","slice","line","join","AbortController","cacheSignal","inputReady","getRuntimeStagePromise","workStore","workAsyncStorage","fallbackParams","fallbackRouteParams","size","use","renderSignal","throwForMissingRequestStore","hasSuspenseRegex","bodyAndImplicitTags","hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex","RegExp","hasMetadataRegex","hasViewportRegex","hasOutletRegex","componentStack","dynamicValidation","test","createErrorWithComponentOrOwnerStack","ownerStack","captureOwnerStack","console","dev","hasReadableErrorStacks","prelude","result","RequestCookies","ResponseCookies","stringifyCookie","ReflectAdapter","target","prop","receiver","value","Reflect","has","deleteProperty","MutableRequestCookiesAdapter","ReadonlyRequestCookiesError","RequestCookiesAdapter","appendMutableCookies","areCookiesMutableInCurrentPhase","createCookiesWithMutableAccessCheck","getModifiedCookieValues","responseCookiesToRequestCookies","callable","seal","cookies","Proxy","SYMBOL_MODIFY_COOKIE_VALUES","Symbol","for","modified","Array","isArray","headers","mutableCookies","modifiedCookieValues","resCookies","returnedCookies","getAll","cookie","wrap","onUpdateCookies","responseCookies","Headers","modifiedValues","modifiedCookies","Set","updateResponseCookies","pathWasRevalidated","allCookies","c","serializedCookies","tempCookies","toString","wrappedCookies","args","add","delete","ensureCookiesAreStillMutable","phase","_callingExpression","requestCookies","createDedupedByCallsiteServerErrorLoggerDev","errorRef","current","cache","fn","logErrorOrWarn","__NEXT_CACHE_COMPONENTS","warn","flushCurrentErrorIfNew","key","getMessage","logDedupedError","callStackFrames","isRequestAPICallableInsideAfter","throwForSearchParamsAccessInUseCache","throwWithStaticGenerationBailoutErrorWithDynamicError","constructorOpt","captureStackTrace","invalidDynamicUsageError","afterTaskStore","afterTaskAsyncStorage","rootTaskSpawnPhase","callingExpression","underlyingCookies","createEmptyCookies","makeUntrackedCookies","makeHangingCookies","exportName","userspaceMutableCookies","makeUntrackedCookiesWithDevWarnings","CachedCookies","cachedPromise","cachedCookies","asyncApiPromises","instrumentCookiesPromiseWithDevWarnings","Runtime","proxiedPromise","warnForSyncAccess","createCookiesAccessError","Object","defineProperties","iterator","replaceableWarningDescriptorForSymbolIterator","replaceableWarningDescriptor","clear","enumerable","defineProperty","writable","configurable","prefix","HeadersAdapter","ReadonlyHeadersError","lowercased","toLowerCase","original","keys","find","o","merge","from","append","existing","forEach","callbackfn","thisArg","entries","call","values","underlyingHeaders","makeUntrackedHeaders","makeHangingHeaders","makeUntrackedHeadersWithDevWarnings","CachedHeaders","cachedHeaders","instrumentHeadersPromiseWithDevWarnings","createHeadersAccessError","getSetCookie","draftMode","createOrGetCachedDraftMode","draftModeProvider","getDraftModeProviderForCacheScope","cacheKey","NullDraftMode","cachedDraftMode","CachedDraftModes","isPrefetchRequest","createDraftModeWithDevWarnings","DraftMode","underlyingProvider","instance","provider","_provider","isEnabled","enable","trackDynamicDraftMode","disable","createDraftModeAccessError"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]}